//
// Created by bacox on 25/05/2020.
//

#include <iostream>
#include <EdgeCaffe.h>
#include <chrono>
#include <Util/Output.h>
#include <cxxopts.h>
#include <Util/Config.h>
#include <Orchestrator/Orchestrator.h>
#include <Orchestrator/OrchestratorFactory.h>

int main(int argc, char *argv[])
{
    /**
     * Vary Rho, fix number of networks
     */

    /**
     * Start parsing input parameters
     */

    EdgeCaffe::Config &c_config = EdgeCaffe::Config::getInstance();

    c_config.parseCli(argc, argv);
    c_config.printConfig();

    std::unordered_map<std::string, int> memory_values = {
            {"512M", 512}
            , {"1G", 1024}
            , {"2G", 2048}
            , {"4G", 4096}

    };
    /**
     * End parsing input parameters
     */

    EdgeCaffe::Type::MODE_TYPE mode =  c_config.modeAsType();
    std::string modeAsString = c_config.mode();
    std::string outputFile = "output.csv";

    {
        EdgeCaffe::Output output;
        std::string configOutputFile = c_config.outputPrefix.valueOrDefault() + "config.csv";
        output.toCSV(c_config.outputDirectory.valueOrDefault() + "/" + configOutputFile, c_config.configAsText, EdgeCaffe::Output::CONFIG);
    }



    /**
     * End of configuring all.
     * The real running begins here
     */
//    if(!verbose)
    ::google::InitGoogleLogging(argv[0]);

    /**
     * Instead of defining the networks and the input, we let it be generated by a distribution
     */
    EdgeCaffe::ArrivalList arrivals;


    std::unique_ptr<EdgeCaffe::OrchestratorFactory> ofactory = std::make_unique<EdgeCaffe::OrchestratorFactory>();
    auto orchest = ofactory->GetOrchestratorAlt();

    /**
     * Check if an arrival-list is given
     * If an arrival-list is present we will you that one instead of generating arrivals
     * If no arrival-list --> generate arrivals according to the distribution
     */

    if( c_config.pathToArrivalList.isSet())
    {
//        std::cout << "I found an arrival-list at " << pathToArrivalList << std::endl;
        arrivals.loadFromYaml(c_config.pathToArrivalList());
    } else
    {
//        std::cout << "No arrivalList to be found" << std::endl;
        arrivals.setEnabledNetworks({c_config.networks()});
        arrivals.setSeed(c_config.seed());

        if (c_config.poissonDistribution())
        {
            arrivals.generateList(c_config.numArrivals(), EdgeCaffe::ArrivalList::DISTRIBUTION_TYPE::POISSON, {c_config.iat()});
        } else
        {
            arrivals.generateList(c_config.numArrivals(), EdgeCaffe::ArrivalList::DISTRIBUTION_TYPE::CONSTANT, {0});
        }
    }
    {
        // Make sure to save the arrival distribution
        std::string arrivalListOutputFile = c_config.defaultOutPath() + "arrivals.csv";
        EdgeCaffe::Output output;
        output.toCSV(arrivalListOutputFile, arrivals.toCSVLines(), EdgeCaffe::Output::ARRIVALS);
    }

    orchest->setArrivals(arrivals);

    auto system_time_start = std::chrono::system_clock::now();
    auto startTime = std::chrono::high_resolution_clock::now();

    orchest->start();
    orchest->processTasks();
    orchest->waitForStop();

    auto endTime = std::chrono::high_resolution_clock::now();
    auto system_time_end = std::chrono::system_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(endTime - startTime).count();
    std::cout << duration << " milliseconds" << std::endl;

    /**
     * Processing the gathered data
     * This part writes the timing information of the layers of the networks to a csv file.
     * It overwrites the specified file. It is important to use a unique filename
     *  for each run of move the data in between runs to prevent losing data.
     */

    std::string layerOutputFile = c_config.defaultOutPath() + outputFile;
    orchest->processLayerData(layerOutputFile);
    std::string queueEventsFile = c_config.defaultOutPath() + "stepEvents.csv";
    orchest->processEventData(queueEventsFile, startTime);
    std::string networkOutputFile = c_config.defaultOutPath() + "networkStats6.csv";
    orchest->processNetworkData(networkOutputFile, startTime);

    /**
     * Save the output of the end-to-end measurement
     * Here we append the measurement to the file
     * If the file does not exist it is created.
     */
    EdgeCaffe::Output output;
    std::string tmp_network = "";
    if(c_config.networks.valueOrDefault().size())
        tmp_network = c_config.networks().front();

    auto start_time_t = std::chrono::system_clock::to_time_t(system_time_start);
    auto end_time_t = std::chrono::system_clock::to_time_t(system_time_end);
    std::string generalLine;
    generalLine = c_config.memoryLimit() + "," + modeAsString + "," + std::to_string(duration) + "," +
                  std::to_string(c_config.numArrivals()) + "," + tmp_network + "," + std::to_string(1) + "," +
                  std::to_string(0) + "," + std::to_string(c_config.iat()) + "," +
                  std::to_string(c_config.numberOfWorkers()) + "," + std::to_string(start_time_t) + "," + std::to_string(end_time_t);
    output.toCSVAppend(c_config.outputDirectory() + "/" + c_config.generalOutputFile(), {generalLine}, EdgeCaffe::Output::PIPELINE_EXT);

    for(const auto worker : orchest->getWorkers())
    {
        auto id = worker->workerId;
        std::string workerStatFile = c_config.defaultOutPath() + "worker" + std::to_string(id) + ".csv";
        auto lines = worker->workerProfileToCSVLines();
        output.toCSV(workerStatFile, lines, EdgeCaffe::Output::WORKER);
    }

    output.toCSV(c_config.defaultOutPath() + "cc-networks.csv", orchest->getNr()->toCSV(), EdgeCaffe::Output::CONCURRENT_NETWORKS);
    return 0;
}